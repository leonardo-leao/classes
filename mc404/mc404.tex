\documentclass{article}

\usepackage[a4paper, hmargin={20mm, 20mm}, vmargin={25mm, 30mm}]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[english, main=portuguese]{babel}

\usepackage[hidelinks]{hyperref}
\usepackage{bookmark}
\usepackage{cancel}
\usepackage{comment}

\usepackage{array}
\usepackage{indentfirst}
\usepackage{multicol}
\setlength{\multicolsep}{2pt}% 50% of original values
\usepackage{subfiles}

\usepackage{titlesec}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{systeme}
\usepackage{float}
\usepackage{enumitem}
\usepackage[thinc]{esdiff} %parcial derivatives
\restylefloat{table}

\usepackage{graphicx}
\usepackage{subcaption}
\graphicspath{ {./images/} }

% Pacote para a definição de novas cores
\usepackage{xcolor}
% Definindo novas cores
\definecolor{darkgreen}{rgb}{0.0, 0.42, 0.24}
\definecolor{darkpurple}{rgb}{0.74, 0.2, 0.64}
\definecolor{darkblue}{rgb}{0.0, 0.28, 0.67}

%Configurando espaços entre paragrafos
%\setlength{\parskip}{0.5em}

\usepackage{chngcntr}
\counterwithin{figure}{section}
\counterwithin{table}{section}
\counterwithin{equation}{section}

%Configurando pacote de Gráficos plots
\usepackage{pgfplots}
\usepackage{tikz}

%Configurando pacote de circuitos
\usepackage{circuitikz}

\tikzset{
    mux2by1/.style={
        muxdemux, muxdemux def={
            Lh=4,
            Rh=2,
            w=2,
            NL=2,
            NB=1,
            NR=1,
            NT=0,
            inset Lh=0,
            inset Rh=0,
            inset w=0,
            square pins=0
        }
    }
}

\tikzset{
    demux2by1/.style={
        muxdemux, muxdemux def={
            Lh=2,
            Rh=4,
            w=2,
            NL=1,
            NB=1,
            NR=2,
            NT=0,
            inset Lh=0,
            inset Rh=0,
            inset w=0,
            square pins=0
        }
    }
}



%Configurando multiple files
\usepackage{filecontents}

%Configurando quotes
\usepackage{csquotes}


%Configurando layout para mostrar códigos
\usepackage{listings}
%Setting default style for code
\newcommand{\myStyleC}{
\lstset{
    language=C,                            % the language of the code
    basicstyle=\ttfamily\small,               % the size of the fonts that are used for the code
    keywordstyle=\color{darkpurple}\bfseries, %
    stringstyle=\color{darkblue},             %
    commentstyle=\color{darkgreen},           %
    morecomment=[s][\color{blue}]{/**}{*/},   %
    extendedchars=true,                       %
    showtabs=false,                           % show tabs within strings adding particular underscores
    showspaces=false,                         % show spaces adding particular underscores
    showstringspaces=false,                   % underline spaces within strings
    numbers=left,                             % where to put the line-numbers
    numberstyle=\tiny\color{gray},            % the style that is used for the line-numbers
    stepnumber=1,                             % the step between two line-numbers. If it's 1, each line will be numbered
    numbersep=5pt,                            % how far the line-numbers are from the code
    frame=single,                             % adds a frame around the code
    rulecolor=\color{black},                  % if not set, the frame-color may be changed on line-breaks within not-black text
    breaklines=true,                          % sets automatic line breaking
    backgroundcolor=\color{white},            % choose the background color
    breakatwhitespace=true,                   % sets if automatic breaks should only happen at whitespace
    breakautoindent=false,                    %
    captionpos=b,                             % sets the caption-position to bottom
    xleftmargin=0pt,                          %
    tabsize=2,                                % sets default tabsize to 2 spaces
}}

%setting bash setup
\newcommand{\myStyleBash}{
\lstset{
    language=Bash,                            % the language of the code
    basicstyle=\ttfamily\small,               % the size of the fonts that are used for the code
    keywordstyle=\color{darkpurple}\bfseries, %
    stringstyle=\color{darkblue},             %
    commentstyle=\color{darkgreen},           %
    morecomment=[s][\color{blue}]{/**}{*/},   %
    extendedchars=true,                       %
    showtabs=false,                           % show tabs within strings adding particular underscores
    showspaces=false,                         % show spaces adding particular underscores
    showstringspaces=false,                   % underline spaces within strings
    numbers=left,                             % where to put the line-numbers
    numberstyle=\tiny\color{gray},            % the style that is used for the line-numbers
    stepnumber=1,                             % the step between two line-numbers. If it's 1, each line will be numbered
    numbersep=5pt,                            % how far the line-numbers are from the code
    frame=single,                             % adds a frame around the code
    rulecolor=\color{black},                  % if not set, the frame-color may be changed on line-breaks within not-black text
    breaklines=true,                          % sets automatic line breaking
    backgroundcolor=\color{white},            % choose the background color
    breakatwhitespace=true,                   % sets if automatic breaks should only happen at whitespace
    breakautoindent=false,                    %
    captionpos=b,                             % sets the caption-position to bottom
    xleftmargin=0pt,                          %
    tabsize=2,                                % sets default tabsize to 2 spaces
}}
%setting VHDL setup
\newcommand{\myStyleVHDL}{
\lstset{
    language=VHDL,                            % the language of the code
    basicstyle=\ttfamily\small,               % the size of the fonts that are used for the code
    keywordstyle=\color{darkpurple}\bfseries, %
    stringstyle=\color{darkblue},             %
    commentstyle=\color{darkgreen},           %
    morecomment=[s][\color{blue}]{/**}{*/},   %
    extendedchars=true,                       %
    showtabs=false,                           % show tabs within strings adding particular underscores
    showspaces=false,                         % show spaces adding particular underscores
    showstringspaces=false,                   % underline spaces within strings
    numbers=left,                             % where to put the line-numbers
    numberstyle=\tiny\color{gray},            % the style that is used for the line-numbers
    stepnumber=1,                             % the step between two line-numbers. If it's 1, each line will be numbered
    numbersep=5pt,                            % how far the line-numbers are from the code
    frame=single,                             % adds a frame around the code
    rulecolor=\color{black},                  % if not set, the frame-color may be changed on line-breaks within not-black text
    breaklines=true,                          % sets automatic line breaking
    backgroundcolor=\color{white},            % choose the background color
    breakatwhitespace=true,                   % sets if automatic breaks should only happen at whitespace
    breakautoindent=false,                    %
    captionpos=b,                             % sets the caption-position to bottom
    xleftmargin=0pt,                          %
    tabsize=2,                                % sets default tabsize to 2 spaces
}}

\newcommand{\myStyleAssembly}{
\lstset{
    language=[x86masm]Assembler,                       % the language of the code
    basicstyle=\ttfamily\small,               % the size of the fonts that are used for the code
    keywordstyle=\color{darkpurple}\bfseries, %
    stringstyle=\color{darkblue},             %
    commentstyle=\color{darkgreen},           %
    morecomment=[s][\color{blue}]{/**}{*/},   %
    extendedchars=true,                       %
    showtabs=false,                           % show tabs within strings adding particular underscores
    showspaces=false,                         % show spaces adding particular underscores
    showstringspaces=false,                   % underline spaces within strings
    numbers=left,                             % where to put the line-numbers
    numberstyle=\tiny\color{gray},            % the style that is used for the line-numbers
    stepnumber=1,                             % the step between two line-numbers. If it's 1, each line will be numbered
    numbersep=5pt,                            % how far the line-numbers are from the code
    frame=single,                             % adds a frame around the code
    rulecolor=\color{black},                  % if not set, the frame-color may be changed on line-breaks within not-black text
    breaklines=true,                          % sets automatic line breaking
    backgroundcolor=\color{white},            % choose the background color
    breakatwhitespace=true,                   % sets if automatic breaks should only happen at whitespace
    breakautoindent=false,                    %
    captionpos=b,                             % sets the caption-position to bottom
    xleftmargin=0pt,                          %
    tabsize=2,                                % sets default tabsize to 2 spaces
}}

%\titleformat{<command>}[<shape>]{<format>}{<label>}{<sep>}{<before-code>}[<after-code>]
\titleformat
{\section} %comand
[block]  %shape
{\normalfont\LARGE} %format
{\thesection. } %label
{0mm} %sep
{} %before-code
[{\titlerule[0.1mm]}] %after-code

\titlespacing*{\section}{0mm}{0mm}{15mm}

\titleformat
{\subsection} %comand
[block]  %shape
{\normalfont\Large} %format
{\thesubsection. } %label
{0mm} %sep
{} %before-code
[] %after-code

\titlespacing*{\subsection}{0mm}{5mm}{2.5mm}


\begin{document}
    \begin{titlepage}
        \begin{center}
            \rule{450pt}{0.5pt}\\[4mm]
            {\Huge MC404 - Organição Básica de Computadores}\\
            \rule{450pt}{0.5pt}\\[2mm]
            {\Large Resumo Teórico}\\[200mm]
            \today\\
            \rule{250pt}{0.5pt}\\
            {\large Guilherme Nunes Trofino}\\
            {\large 217276}\\
        \end{center}
    \end{titlepage}
\newpage

    \tableofcontents
\newpage

    \paragraph{Instruções}Comandos necessários para que o simulador seja aberto a partir do terminal: 
        \begin{scriptsize}
            \myStyleBash
            \begin{lstlisting}
    cd classes/mc404/nand2tetris/tools/
    chmod 755 HardwareSimulator.sh
    ./HardwareSimulator.sh

    chmod 755 CPUEmulator.sh
    ./CPUEmulator.sh 
            \end{lstlisting}
        \end{scriptsize}
\newpage

    \section{Projeto 1}
        \subsection{Not}
            \paragraph{Definição}[Funcionamento]

            \paragraph{Tabela Verdade}Esta porta lógica possuirá a seguinte tabela verdade:
                \begin{table}[H]
                    \centering  
                    \begin{tabular}[]{c|c}\hline
                        in & out\\\hline
                        0  & 1\\
                        1  & 0\\\hline
                    \end{tabular}
                    \caption{Tabela Verdade Not}
                \end{table}

            \paragraph{Representação}Esta porta lógica pode ser expressa pelo seguinte circuito:
                \begin{figure}[H]
                    \centering
                    \begin{circuitikz}
                        \ctikzset{component text=left}
                        \draw
                        (0,0) node[not port] (myPort) {not}
                        (myPort.in 1) node [anchor = east] {in}
                        (myPort.out)  node [anchor = west] {out};
                    \end{circuitikz} 
                    \caption{Porta Lógica Not}
                \end{figure} \noindent

            \paragraph{Implementação}Esta porta lógica pode ser implementada de acordo com o seguinte código:
                \begin{scriptsize}
                    \myStyleVHDL
                    \lstinputlisting{./nand2tetris/projects/01/Not.hdl}
                \end{scriptsize}
\newpage

        \subsection{And}
            \paragraph{Definição}[Funcionamento]

            \paragraph{Tabela Verdade}Esta porta lógica possuirá a seguinte tabela verdade:
                \begin{table}[H]
                    \centering
                    \begin{tabular}[]{cc|c}\hline
                        a & b & out\\\hline
                        0 & 0 & 0\\
                        0 & 1 & 0\\
                        1 & 0 & 0\\
                        1 & 1 & 1\\\hline
                    \end{tabular}
                    \caption{Tabela Verdade And}
                \end{table}

            \paragraph{Representação}Esta porta lógica pode ser expressa pelo seguinte circuito:
                \begin{figure}[H]
                    \centering
                    \begin{circuitikz}
                        \ctikzset{component text=left}
                        \draw
                        (0,0) node[and port] (myPort) {and}
                        (myPort.in 1) node [anchor = east] {a}
                        (myPort.in 2) node [anchor = east] {b}
                        (myPort.out)  node [anchor = west] {out};
                    \end{circuitikz} 
                    \caption{Porta Lógica And}
                \end{figure} \noindent

            \paragraph{Implementação}Esta porta lógica pode ser implementada de acordo com o seguinte código:
                \begin{scriptsize}
                    \myStyleVHDL
                    \lstinputlisting{./nand2tetris/projects/01/And.hdl}
                \end{scriptsize}
\newpage

        \subsection{Or}
            \paragraph{Definição}[Funcionamento]

            \paragraph{Tabela Verdade}Esta porta lógica possuirá a seguinte tabela verdade:
                \begin{table}[H]
                    \centering
                    \begin{tabular}[]{cc|c}\hline
                        a & b & out\\\hline
                        0 & 0 & 0\\
                        0 & 1 & 1\\
                        1 & 0 & 1\\
                        1 & 1 & 1\\\hline
                    \end{tabular}
                    \caption{Tabela Verdade Or}
                \end{table}

            \paragraph{Representação}Esta porta lógica pode ser expressa pelo seguinte circuito:
                \begin{figure}[H]
                    \centering
                    \begin{circuitikz}
                        \ctikzset{component text=left}
                        \draw
                        (0,0) node[or port] (myPort) {or}
                        (myPort.in 1) node [anchor = east] {a}
                        (myPort.in 2) node [anchor = east] {b}
                        (myPort.out)  node [anchor = west] {out};
                    \end{circuitikz} 
                    \caption{Porta Lógica Or}
                \end{figure} \noindent

            \paragraph{Implementação}Esta porta lógica pode ser implementada de acordo com o seguinte código:
                \begin{scriptsize}
                    \myStyleVHDL
                    \lstinputlisting{./nand2tetris/projects/01/Or.hdl}
                \end{scriptsize}
\newpage

        \subsection{Xor}
            \paragraph{Definição}[Funcionamento]

            \paragraph{Tabela Verdade}Esta porta lógica possuirá a seguinte tabela verdade:
                \begin{table}[H]
                    \centering
                    \begin{tabular}[]{cc|c}\hline
                        a & b & out\\\hline
                        0 & 0 & 0\\
                        0 & 1 & 1\\
                        1 & 0 & 1\\
                        1 & 1 & 0\\\hline
                    \end{tabular}
                    \caption{Tabela Verdade Xor}
                \end{table}

            \paragraph{Representação}Esta porta lógica pode ser expressa pelo seguinte circuito:
                \begin{figure}[H]
                    \centering
                    \begin{circuitikz}
                        \ctikzset{component text=left}
                        \draw
                        (0,0) node[xor port] (myPort) {xor}
                        (myPort.in 1) node [anchor = east] {a}
                        (myPort.in 2) node [anchor = east] {b}
                        (myPort.out)  node [anchor = west] {out};
                    \end{circuitikz} 
                    \caption{Porta Lógica Xor}
                \end{figure} \noindent

            \paragraph{Implementação}Esta porta lógica pode ser implementada de acordo com o seguinte código:
                \begin{scriptsize}
                    \myStyleVHDL
                    \lstinputlisting{./nand2tetris/projects/01/Xor.hdl}
                \end{scriptsize}
\newpage

        \subsection{Mux}
            \paragraph{Definição}[Funcionamento]

            \paragraph{Tabela Verdade}Esta porta lógica possuirá a seguinte tabela verdade:
                \begin{table}[H]
                    \centering
                    \begin{tabular}[]{ccc|c}\hline
                        s & a & b & out\\\hline
                        0 & \textcolor{red}{0} & \textcolor{blue}{0} & \textcolor{red}{0}\\
                        0 & \textcolor{red}{0} & \textcolor{blue}{1} & \textcolor{red}{0}\\
                        0 & \textcolor{red}{1} & \textcolor{blue}{0} & \textcolor{red}{1}\\
                        0 & \textcolor{red}{1} & \textcolor{blue}{1} & \textcolor{red}{1}\\
                        1 & \textcolor{red}{0} & \textcolor{blue}{0} & \textcolor{blue}{0}\\
                        1 & \textcolor{red}{0} & \textcolor{blue}{1} & \textcolor{blue}{1}\\
                        1 & \textcolor{red}{1} & \textcolor{blue}{0} & \textcolor{blue}{0}\\
                        1 & \textcolor{red}{1} & \textcolor{blue}{1} & \textcolor{blue}{1}\\
                    \end{tabular}
                    \caption{Tabela Verdade Mux}
                \end{table}

            \paragraph{Representação}Esta porta lógica pode ser expressa pelo seguinte circuito:
                \begin{figure}[H]
                    \centering
                    \begin{circuitikz}
                        \ctikzset{component text=left}
                        \draw
                        (0,0) node[mux2by1] (myPort) {mux}
                        (myPort.lpin 1) node [anchor = east] {a}
                        (myPort.lpin 2) node [anchor = east] {b}
                        (myPort.bpin 1) node [anchor = north] {s}
                        (myPort.rpin 1)  node [anchor = west] {out};
                    \end{circuitikz} 
                    \caption{Porta Lógica Mux}
                \end{figure} \noindent

            \paragraph{Implementação}Esta porta lógica pode ser implementada de acordo com o seguinte código:
                \begin{scriptsize}
                    \myStyleVHDL
                    \lstinputlisting{./nand2tetris/projects/01/Mux.hdl}
                \end{scriptsize}
\newpage

        \subsection{DMux}
            \paragraph{Definição}[Funcionamento]

            \paragraph{Tabela Verdade}Esta porta lógica possuirá a seguinte tabela verdade:
                \begin{table}[H]
                    \centering
                    \begin{tabular}[]{cc|cc}\hline
                        s & in & a & b\\\hline
                        0 & \textcolor{blue}{0}  & \textcolor{blue}{0} & 0 \\
                        0 & \textcolor{blue}{1}  & \textcolor{blue}{1} & 0 \\
                        1 & \textcolor{blue}{0}  & 0                   & \textcolor{blue}{0}\\
                        1 & \textcolor{blue}{1}  & 0                   & \textcolor{blue}{1}\\\hline
                    \end{tabular}
                    \caption{Tabela Verdade DMux}
                \end{table}

            \paragraph{Representação}Esta porta lógica pode ser expressa pelo seguinte circuito:
                \begin{figure}[H]
                    \centering
                    \begin{circuitikz}
                        \ctikzset{component text=left}
                        \draw
                        (0,0) node[demux2by1] (myPort) {dmux}
                        (myPort.rpin 1) node [anchor = west] {a}
                        (myPort.rpin 2) node [anchor = west] {b}
                        (myPort.bpin 1) node [anchor = north] {s}
                        (myPort.lpin 1) node [anchor = east] {in};
                    \end{circuitikz} 
                    \caption{Porta Lógica DMux}
                \end{figure} \noindent

            \paragraph{Implementação}Esta porta lógica pode ser implementada de acordo com o seguinte código:
                \begin{scriptsize}
                    \myStyleVHDL
                    \lstinputlisting{./nand2tetris/projects/01/DMux.hdl}
                \end{scriptsize}
\newpage

        \subsection{Not16}
            \paragraph{Definição}[Funcionamento]

            \paragraph{Tabela Verdade}Esta porta lógica possuirá a seguinte tabela verdade:
                \begin{table}[H]
                    \centering
                    \begin{tabular}[]{c|c}\hline
                        in[i] & out[i]\\\hline
                        0     & 1\\
                        1     & 0\\\hline
                    \end{tabular}
                    \caption{Tabela Verdade Not16}
                \end{table}

            \paragraph{Representação}Esta porta lógica pode ser expressa pelo seguinte circuito:
                \begin{figure}[H]
                    \centering
                    \begin{circuitikz}
                        \ctikzset{component text=left}
                        \draw
                        (0,0) node[not port] (myPort) {\scriptsize not16}
                        (myPort.in 1) to[multiwire=16] (-1,0)
                        (-1,0) node [anchor = east] {in[16]}
                        (1,0) to[multiwire=16] (myPort.out)
                        (1,0) node [anchor = west] {out[16]};
                    \end{circuitikz} 
                    \caption{Porta Lógica Not16}
                \end{figure} \noindent

            \paragraph{Implementação}Esta porta lógica pode ser implementada de acordo com o seguinte código:
                \begin{scriptsize}
                    \myStyleVHDL
                    \lstinputlisting{./nand2tetris/projects/01/Not16.hdl}
                \end{scriptsize}
\newpage

    \subsection{And16}
        \paragraph{Definição}[Funcionamento]

        \paragraph{Tabela Verdade}Esta porta lógica possuirá a seguinte tabela verdade:
            \begin{table}[H]
                \centering
                \begin{tabular}[]{cc|c}\hline
                    a[i] & b[i] & out[i]\\\hline
                    0    & 0    & 0\\
                    0    & 1    & 0\\
                    1    & 0    & 0\\
                    1    & 1    & 1\\\hline
                \end{tabular}
                \caption{Tabela Verdade And16}
            \end{table}

        \paragraph{Representação}Esta porta lógica pode ser expressa pelo seguinte circuito:
            \begin{figure}[H]
                \centering
                \begin{circuitikz}
                    \ctikzset{component text=left}
                    \draw
                    (0,0) node[and port] (myPort) {\scriptsize and16}
                    (-2,0.275) node [anchor = east] {a}
                    (-2,0.275) to[multiwire=16] (myPort.in 1)

                    (-2,-0.275) node [anchor = east] {b}
                    (myPort.in 2) to[multiwire=16] (-2,-0.275)

                    (1,0) node [anchor = west] {out};
                \end{circuitikz}
                \caption{Porta Lógica And16}
            \end{figure} \noindent

        \paragraph{Implementação}Esta porta lógica pode ser implementada de acordo com o seguinte código:
            \begin{scriptsize}
                \myStyleVHDL
                \lstinputlisting{./nand2tetris/projects/01/And16.hdl}
            \end{scriptsize}
\newpage

        \subsection{OR16}
            \paragraph{Definição}[Funcionamento]

            \paragraph{Tabela Verdade}Esta porta lógica possuirá a seguinte tabela verdade:
                \begin{table}[H]
                    \centering
                    \begin{tabular}[]{cc|c}\hline
                        a & b & out\\\hline
                        0 & 1 & 1\\
                        0 & 1 & 1\\
                        0 & 1 & 1\\
                        0 & 1 & 1\\\hline
                    \end{tabular}
                    \caption{Tabela Verdade OR16}
                \end{table}

            \paragraph{Representação}Esta porta lógica pode ser expressa pelo seguinte circuito:
                \begin{figure}[H]
                    \centering
                    \begin{circuitikz}
                        \ctikzset{component text=left}
                        \draw
                        (0,0) node[or port] (myPort) {OR16}
                        (myPort.in 1) node [anchor = east] {a}
                        (myPort.in 2) node [anchor = east] {b}
                        (myPort.out)  node [anchor = west] {out};
                    \end{circuitikz} 
                    \caption{Porta Lógica OR16}
                \end{figure} \noindent

            \paragraph{Implementação}Esta porta lógica pode ser implementada de acordo com o seguinte código:
                \begin{scriptsize}
                    \myStyleVHDL
                    \lstinputlisting{./nand2tetris/projects/01/Or16.hdl}
                \end{scriptsize}
\newpage

    \subsection{MUX16}
        \paragraph{Definição}[Funcionamento]

        \paragraph{Tabela Verdade}Esta porta lógica possuirá a seguinte tabela verdade:
            \begin{table}[H]
                \centering
                \begin{tabular}[]{cc|c}\hline
                    a & b & out\\\hline
                    0 & 1 & 1\\
                    0 & 1 & 1\\
                    0 & 1 & 1\\
                    0 & 1 & 1\\\hline
                \end{tabular}
                \caption{Tabela Verdade MUX16}
            \end{table}

        \paragraph{Representação}Esta porta lógica pode ser expressa pelo seguinte circuito:
            \begin{figure}[H]
                \centering
                \begin{circuitikz}
                    \ctikzset{component text=left}
                    \draw
                    (0,0) node[muxdemux] (myPort) {MUX16};
                    % (myPort.in 1) node [anchor = east] {a}
                    % (myPort.in 2) node [anchor = east] {b}
                    % (myPort.out)  node [anchor = west] {out};
                \end{circuitikz} 
                \caption{Porta Lógica MUX16}
            \end{figure} \noindent

        \paragraph{Implementação}Esta porta lógica pode ser implementada de acordo com o seguinte código:
            \begin{scriptsize}
                \myStyleVHDL
                \lstinputlisting{./nand2tetris/projects/01/Mux16.hdl}
            \end{scriptsize}
\newpage

        \subsection{OR8WAY}
            \paragraph{Definição}[Funcionamento]

            \paragraph{Tabela Verdade}Esta porta lógica possuirá a seguinte tabela verdade:
                \begin{table}[H]
                    \centering
                    \begin{tabular}[]{cc|c}\hline
                        a & b & out\\\hline
                        0 & 1 & 1\\
                        0 & 1 & 1\\
                        0 & 1 & 1\\
                        0 & 1 & 1\\\hline
                    \end{tabular}
                    \caption{Tabela Verdade OR8WAY}
                \end{table}

            \paragraph{Representação}Esta porta lógica pode ser expressa pelo seguinte circuito:
                \begin{figure}[H]
                    \centering
                    \begin{circuitikz}
                        \ctikzset{component text=left}
                        \draw
                        (0,0) node[or port] (myPort) {OR8WAY}
                        (myPort.in 1) node [anchor = east] {a}
                        (myPort.in 2) node [anchor = east] {b}
                        (myPort.out)  node [anchor = west] {out};
                    \end{circuitikz} 
                    \caption{Porta Lógica OR8WAY}
                \end{figure} \noindent

            \paragraph{Implementação}Esta porta lógica pode ser implementada de acordo com o seguinte código:
                \begin{scriptsize}
                    \myStyleVHDL
                    \lstinputlisting{./nand2tetris/projects/01/Or8Way.hdl}
                \end{scriptsize}
\newpage

        \subsection{MUX4WAY16}
            \paragraph{Definição}[Funcionamento]

            \paragraph{Tabela Verdade}Esta porta lógica possuirá a seguinte tabela verdade:
                \begin{table}[H]
                    \centering
                    \begin{tabular}[]{cc|c}\hline
                        a & b & out\\\hline
                        0 & 1 & 1\\
                        0 & 1 & 1\\
                        0 & 1 & 1\\
                        0 & 1 & 1\\\hline
                    \end{tabular}
                    \caption{Tabela Verdade MUX4WAY16}
                \end{table}

            \paragraph{Representação}Esta porta lógica pode ser expressa pelo seguinte circuito:
                \begin{figure}[H]
                    \centering
                    \begin{circuitikz}
                        \ctikzset{component text=left}
                        \draw
                        (0,0) node[muxdemux] (myPort) {MUX4WAY16};
                        % (myPort.in 1) node [anchor = east] {a}
                        % (myPort.in 2) node [anchor = east] {b}
                        % (myPort.out)  node [anchor = west] {out};
                    \end{circuitikz} 
                    \caption{Porta Lógica MUX4WAY16}
                \end{figure} \noindent

            \paragraph{Implementação}Esta porta lógica pode ser implementada de acordo com o seguinte código:
                \begin{scriptsize}
                    \myStyleVHDL
                    \lstinputlisting{./nand2tetris/projects/01/Mux4Way16.hdl}
                \end{scriptsize}
\newpage

        \subsection{MUX8WAY16}
            \paragraph{Definição}[Funcionamento]

            \paragraph{Tabela Verdade}Esta porta lógica possuirá a seguinte tabela verdade:
                \begin{table}[H]
                    \centering
                    \begin{tabular}[]{cc|c}\hline
                        a & b & out\\\hline
                        0 & 1 & 1\\
                        0 & 1 & 1\\
                        0 & 1 & 1\\
                        0 & 1 & 1\\\hline
                    \end{tabular}
                    \caption{Tabela Verdade MUX8WAY16}
                \end{table}

            \paragraph{Representação}Esta porta lógica pode ser expressa pelo seguinte circuito:
                \begin{figure}[H]
                    \centering
                    \begin{circuitikz}
                        \ctikzset{component text=left}
                        \draw
                        (0,0) node[muxdemux] (myPort) {MUX8WAY16};
                        % (myPort.in 1) node [anchor = east] {a}
                        % (myPort.in 2) node [anchor = east] {b}
                        % (myPort.out)  node [anchor = west] {out};
                    \end{circuitikz} 
                    \caption{Porta Lógica MUX8WAY16}
                \end{figure} \noindent

            \paragraph{Implementação}Esta porta lógica pode ser implementada de acordo com o seguinte código:
                \begin{scriptsize}
                    \myStyleVHDL
                    \lstinputlisting{./nand2tetris/projects/01/Mux8Way16.hdl}
                \end{scriptsize}
\newpage

        \subsection{DMUX4WAY}
            \paragraph{Definição}[Funcionamento]

            \paragraph{Tabela Verdade}Esta porta lógica possuirá a seguinte tabela verdade:
                \begin{table}[H]
                    \centering
                    \begin{tabular}[]{cc|c}\hline
                        a & b & out\\\hline
                        0 & 1 & 1\\
                        0 & 1 & 1\\
                        0 & 1 & 1\\
                        0 & 1 & 1\\\hline
                    \end{tabular}
                    \caption{Tabela Verdade DMUX4WAY}
                \end{table}

            \paragraph{Representação}Esta porta lógica pode ser expressa pelo seguinte circuito:
                \begin{figure}[H]
                    \centering
                    \begin{circuitikz}
                        \ctikzset{component text=left}
                        \draw
                        (0,0) node[demux] (myPort) {DMUX4WAY};
                        % (myPort.in 1) node [anchor = east] {a}
                        % (myPort.in 2) node [anchor = east] {b}
                        % (myPort.out)  node [anchor = west] {out};
                    \end{circuitikz} 
                    \caption{Porta Lógica DMUX4WAY}
                \end{figure} \noindent

            \paragraph{Implementação}Esta porta lógica pode ser implementada de acordo com o seguinte código:
                \begin{scriptsize}
                    \myStyleVHDL
                    \lstinputlisting{./nand2tetris/projects/01/DMux4Way.hdl}
                \end{scriptsize}
\newpage

        \subsection{DMUX8WAY}
            \paragraph{Definição}[Funcionamento]

            \paragraph{Tabela Verdade}Esta porta lógica possuirá a seguinte tabela verdade:
                \begin{table}[H]
                    \centering
                    \begin{tabular}[]{cc|c}\hline
                        a & b & out\\\hline
                        0 & 1 & 1\\
                        0 & 1 & 1\\
                        0 & 1 & 1\\
                        0 & 1 & 1\\\hline
                    \end{tabular}
                    \caption{Tabela Verdade DMUX8WAY}
                \end{table}

            \paragraph{Representação}Esta porta lógica pode ser expressa pelo seguinte circuito:
                \begin{figure}[H]
                    \centering
                    \begin{circuitikz}
                        \ctikzset{component text=left}
                        \draw
                        (0,0) node[demux] (myPort) {DMUX8WAY};
                        % (myPort.in 1) node [anchor = east] {a}
                        % (myPort.in 2) node [anchor = east] {b}
                        % (myPort.out)  node [anchor = west] {out};
                    \end{circuitikz} 
                    \caption{Porta Lógica DMUX8WAY}
                \end{figure} \noindent

            \paragraph{Implementação}Esta porta lógica pode ser implementada de acordo com o seguinte código:
                \begin{scriptsize}
                    \myStyleVHDL
                    \lstinputlisting{./nand2tetris/projects/01/DMux8Way.hdl}
                \end{scriptsize}
\newpage

    \section{Projeto 2}
        \subsection{HalfAdder}
            \paragraph{Definição}[Funcionamento]

            \paragraph{Tabela Verdade}Esta porta lógica possuirá a seguinte tabela verdade:
                \begin{table}[H]
                    \centering
                    \begin{tabular}[]{cc|cc}\hline
                        a & b & sum & out\\\hline
                        0 & 0 & 0   & 0\\
                        0 & 1 & 1   & 0\\
                        1 & 0 & 1   & 0\\
                        1 & 1 & 0   & 1\\\hline
                    \end{tabular}
                    \caption{Tabela Verdade HalfAdder}
                \end{table}

            \paragraph{Representação}Esta porta lógica pode ser expressa pelo seguinte circuito:
                \begin{figure}[H]
                    \centering
                    \begin{circuitikz}
                        \ctikzset{component text=left}
                        \draw;
                        % (0,0) node[demux] (myPort) {HalfAdder};
                        % (myPort.in 1) node [anchor = east] {a}
                        % (myPort.in 2) node [anchor = east] {b}
                        % (myPort.out)  node [anchor = west] {out};
                    \end{circuitikz} 
                    \caption{Porta Lógica HalfAdder}
                \end{figure} \noindent

            \paragraph{Implementação}Esta porta lógica pode ser implementada de acordo com o seguinte código:
                \begin{scriptsize}
                    \myStyleVHDL
                    \lstinputlisting{./nand2tetris/projects/02/HalfAdder.hdl}
                \end{scriptsize}
\newpage
    
        \subsection{FullAdder}
            \paragraph{Definição}[Funcionamento]

            \paragraph{Tabela Verdade}Esta porta lógica possuirá a seguinte tabela verdade:
                \begin{table}[H]
                    \centering
                    \begin{tabular}[]{cc|c}\hline
                        a & b & out\\\hline
                        0 & 1 & 1\\
                        0 & 1 & 1\\
                        0 & 1 & 1\\
                        0 & 1 & 1\\\hline
                    \end{tabular}
                    \caption{Tabela Verdade FullAdder}
                \end{table}

            \paragraph{Representação}Esta porta lógica pode ser expressa pelo seguinte circuito:
                \begin{figure}[H]
                    \centering
                    \begin{circuitikz}
                        \ctikzset{component text=left}
                        \draw;
                        % (0,0) node[demux] (myPort) {HalfAdder};
                        % (myPort.in 1) node [anchor = east] {a}
                        % (myPort.in 2) node [anchor = east] {b}
                        % (myPort.out)  node [anchor = west] {out};
                    \end{circuitikz} 
                    \caption{Porta Lógica FullAdder}
                \end{figure} \noindent

            \paragraph{Implementação}Esta porta lógica pode ser implementada de acordo com o seguinte código:
                \begin{scriptsize}
                    \myStyleVHDL
                    \lstinputlisting{./nand2tetris/projects/02/FullAdder.hdl}
                \end{scriptsize}
\newpage

        \subsection{Add16}
            \paragraph{Definição}[Funcionamento]

            \paragraph{Tabela Verdade}Esta porta lógica possuirá a seguinte tabela verdade:
                \begin{table}[H]
                    \centering
                    \begin{tabular}[]{cc|c}\hline
                        a & b & out\\\hline
                        0 & 1 & 1\\
                        0 & 1 & 1\\
                        0 & 1 & 1\\
                        0 & 1 & 1\\\hline
                    \end{tabular}
                    \caption{Tabela Verdade Add16}
                \end{table}

            \paragraph{Representação}Esta porta lógica pode ser expressa pelo seguinte circuito:
                \begin{figure}[H]
                    \centering
                    \begin{circuitikz}
                        \ctikzset{component text=left}
                        \draw;
                        % (0,0) node[demux] (myPort) {HalfAdder};
                        % (myPort.in 1) node [anchor = east] {a}
                        % (myPort.in 2) node [anchor = east] {b}
                        % (myPort.out)  node [anchor = west] {out};
                    \end{circuitikz} 
                    \caption{Porta Lógica Add16}
                \end{figure} \noindent

            \paragraph{Implementação}Esta porta lógica pode ser implementada de acordo com o seguinte código:
                \begin{scriptsize}
                    \myStyleVHDL
                    \lstinputlisting{./nand2tetris/projects/02/Add16.hdl}
                \end{scriptsize}
\newpage

        \subsection{Inc16}
            \paragraph{Definição}[Funcionamento]

            \paragraph{Tabela Verdade}Esta porta lógica possuirá a seguinte tabela verdade:
                \begin{table}[H]
                    \centering
                    \begin{tabular}[]{cc|c}\hline
                        a & b & out\\\hline
                        0 & 1 & 1\\
                        0 & 1 & 1\\
                        0 & 1 & 1\\
                        0 & 1 & 1\\\hline
                    \end{tabular}
                    \caption{Tabela Verdade Inc16}
                \end{table}

            \paragraph{Representação}Esta porta lógica pode ser expressa pelo seguinte circuito:
                \begin{figure}[H]
                    \centering
                    \begin{circuitikz}
                        \ctikzset{component text=left}
                        \draw;
                        % (0,0) node[demux] (myPort) {HalfAdder};
                        % (myPort.in 1) node [anchor = east] {a}
                        % (myPort.in 2) node [anchor = east] {b}
                        % (myPort.out)  node [anchor = west] {out};
                    \end{circuitikz} 
                    \caption{Porta Lógica Inc16}
                \end{figure} \noindent

            \paragraph{Implementação}Esta porta lógica pode ser implementada de acordo com o seguinte código:
                \begin{scriptsize}
                    \myStyleVHDL
                    \lstinputlisting{./nand2tetris/projects/02/Inc16.hdl}
                \end{scriptsize}
\newpage

        \subsection{ALU}
            \paragraph{Definição}[Funcionamento]

            \paragraph{Tabela Verdade}Esta porta lógica possuirá a seguinte tabela verdade:
                \begin{table}[H]
                    \centering
                    \begin{tabular}[]{cc|c}\hline
                        a & b & out\\\hline
                        0 & 1 & 1\\
                        0 & 1 & 1\\
                        0 & 1 & 1\\
                        0 & 1 & 1\\\hline
                    \end{tabular}
                    \caption{Tabela Verdade ALU}
                \end{table}

            \paragraph{Representação}Esta porta lógica pode ser expressa pelo seguinte circuito:
                \begin{figure}[H]
                    \centering
                    \begin{circuitikz}
                        \ctikzset{component text=left}
                        \draw;
                        % (0,0) node[demux] (myPort) {HalfAdder};
                        % (myPort.in 1) node [anchor = east] {a}
                        % (myPort.in 2) node [anchor = east] {b}
                        % (myPort.out)  node [anchor = west] {out};
                    \end{circuitikz} 
                    \caption{Porta Lógica ALU}
                \end{figure} \noindent

            \paragraph{Implementação}Esta porta lógica pode ser implementada de acordo com o seguinte código:
                \begin{scriptsize}
                    \myStyleVHDL
                    \lstinputlisting{./nand2tetris/projects/02/ALU.hdl}
                \end{scriptsize}
\newpage

    \section{Projeto 3}
        \subsection{Bit}
            \paragraph{Definição}[Funcionamento]

            \paragraph{Tabela Verdade}Esta porta lógica possuirá a seguinte tabela verdade:
                \begin{table}[H]
                    \centering
                    \begin{tabular}[]{cc|c}\hline
                        a & b & out\\\hline
                        0 & 1 & 1\\
                        0 & 1 & 1\\
                        0 & 1 & 1\\
                        0 & 1 & 1\\\hline
                    \end{tabular}
                    \caption{Tabela Verdade Bit}
                \end{table}

            \paragraph{Representação}Esta porta lógica pode ser expressa pelo seguinte circuito:
                \begin{figure}[H]
                    \centering
                    \begin{circuitikz}
                        \ctikzset{component text=left}
                        \draw;
                        % (0,0) node[demux] (myPort) {HalfAdder};
                        % (myPort.in 1) node [anchor = east] {a}
                        % (myPort.in 2) node [anchor = east] {b}
                        % (myPort.out)  node [anchor = west] {out};
                    \end{circuitikz} 
                    \caption{Porta Lógica Bit}
                \end{figure} \noindent

            \paragraph{Implementação}Esta porta lógica pode ser implementada de acordo com o seguinte código:
                \begin{scriptsize}
                    \myStyleVHDL
                    \lstinputlisting{./nand2tetris/projects/03/a/Bit.hdl}
                \end{scriptsize}
\newpage

        \subsection{Register}
            \paragraph{Definição}[Funcionamento]

            \paragraph{Tabela Verdade}Esta porta lógica possuirá a seguinte tabela verdade:
                \begin{table}[H]
                    \centering
                    \begin{tabular}[]{cc|c}\hline
                        a & b & out\\\hline
                        0 & 1 & 1\\
                        0 & 1 & 1\\
                        0 & 1 & 1\\
                        0 & 1 & 1\\\hline
                    \end{tabular}
                    \caption{Tabela Verdade Register}
                \end{table}

            \paragraph{Representação}Esta porta lógica pode ser expressa pelo seguinte circuito:
                \begin{figure}[H]
                    \centering
                    \begin{circuitikz}
                        \ctikzset{component text=left}
                        \draw;
                        % (0,0) node[demux] (myPort) {HalfAdder};
                        % (myPort.in 1) node [anchor = east] {a}
                        % (myPort.in 2) node [anchor = east] {b}
                        % (myPort.out)  node [anchor = west] {out};
                    \end{circuitikz} 
                    \caption{Porta Lógica Register}
                \end{figure} \noindent

            \paragraph{Implementação}Esta porta lógica pode ser implementada de acordo com o seguinte código:
                \begin{scriptsize}
                    \myStyleVHDL
                    \lstinputlisting{./nand2tetris/projects/03/a/Register.hdl}
                \end{scriptsize}
\newpage

    \subsection{RAM8}
        \paragraph{Definição}[Funcionamento]

        \paragraph{Tabela Verdade}Esta porta lógica possuirá a seguinte tabela verdade:
            \begin{table}[H]
                \centering
                \begin{tabular}[]{cc|c}\hline
                    a & b & out\\\hline
                    0 & 1 & 1\\
                    0 & 1 & 1\\
                    0 & 1 & 1\\
                    0 & 1 & 1\\\hline
                \end{tabular}
                \caption{Tabela Verdade RAM8}
            \end{table}

        \paragraph{Representação}Esta porta lógica pode ser expressa pelo seguinte circuito:
            \begin{figure}[H]
                \centering
                \begin{circuitikz}
                    \ctikzset{component text=left}
                    \draw;
                    % (0,0) node[demux] (myPort) {HalfAdder};
                    % (myPort.in 1) node [anchor = east] {a}
                    % (myPort.in 2) node [anchor = east] {b}
                    % (myPort.out)  node [anchor = west] {out};
                \end{circuitikz} 
                \caption{Porta Lógica RAM8}
            \end{figure} \noindent

        \paragraph{Implementação}Esta porta lógica pode ser implementada de acordo com o seguinte código:
            \begin{scriptsize}
                \myStyleVHDL
                \lstinputlisting{./nand2tetris/projects/03/a/RAM8.hdl}
            \end{scriptsize}
\newpage

    \subsection{RAM64}
        \paragraph{Definição}[Funcionamento]

        \paragraph{Tabela Verdade}Esta porta lógica possuirá a seguinte tabela verdade:
            \begin{table}[H]
                \centering
                \begin{tabular}[]{cc|c}\hline
                    a & b & out\\\hline
                    0 & 1 & 1\\
                    0 & 1 & 1\\
                    0 & 1 & 1\\
                    0 & 1 & 1\\\hline
                \end{tabular}
                \caption{Tabela Verdade RAM64}
            \end{table}

        \paragraph{Representação}Esta porta lógica pode ser expressa pelo seguinte circuito:
            \begin{figure}[H]
                \centering
                \begin{circuitikz}
                    \ctikzset{component text=left}
                    \draw;
                    % (0,0) node[demux] (myPort) {HalfAdder};
                    % (myPort.in 1) node [anchor = east] {a}
                    % (myPort.in 2) node [anchor = east] {b}
                    % (myPort.out)  node [anchor = west] {out};
                \end{circuitikz} 
                \caption{Porta Lógica RAM64}
            \end{figure} \noindent

        \paragraph{Implementação}Esta porta lógica pode ser implementada de acordo com o seguinte código:
            \begin{scriptsize}
                \myStyleVHDL
                \lstinputlisting{./nand2tetris/projects/03/a/RAM64.hdl}
            \end{scriptsize}
\newpage

    \subsection{RAM512}
        \paragraph{Definição}[Funcionamento]

        \paragraph{Tabela Verdade}Esta porta lógica possuirá a seguinte tabela verdade:
            \begin{table}[H]
                \centering
                \begin{tabular}[]{cc|c}\hline
                    a & b & out\\\hline
                    0 & 1 & 1\\
                    0 & 1 & 1\\
                    0 & 1 & 1\\
                    0 & 1 & 1\\\hline
                \end{tabular}
                \caption{Tabela Verdade RAM512}
            \end{table}

        \paragraph{Representação}Esta porta lógica pode ser expressa pelo seguinte circuito:
            \begin{figure}[H]
                \centering
                \begin{circuitikz}
                    \ctikzset{component text=left}
                    \draw;
                    % (0,0) node[demux] (myPort) {HalfAdder};
                    % (myPort.in 1) node [anchor = east] {a}
                    % (myPort.in 2) node [anchor = east] {b}
                    % (myPort.out)  node [anchor = west] {out};
                \end{circuitikz} 
                \caption{Porta Lógica RAM512}
            \end{figure} \noindent

        \paragraph{Implementação}Esta porta lógica pode ser implementada de acordo com o seguinte código:
            \begin{scriptsize}
                \myStyleVHDL
                \lstinputlisting{./nand2tetris/projects/03/b/RAM512.hdl}
            \end{scriptsize}
\newpage

    \subsection{RAM4K}
        \paragraph{Definição}[Funcionamento]

        \paragraph{Tabela Verdade}Esta porta lógica possuirá a seguinte tabela verdade:
            \begin{table}[H]
                \centering
                \begin{tabular}[]{cc|c}\hline
                    a & b & out\\\hline
                    0 & 1 & 1\\
                    0 & 1 & 1\\
                    0 & 1 & 1\\
                    0 & 1 & 1\\\hline
                \end{tabular}
                \caption{Tabela Verdade RAM4K}
            \end{table}

        \paragraph{Representação}Esta porta lógica pode ser expressa pelo seguinte circuito:
            \begin{figure}[H]
                \centering
                \begin{circuitikz}
                    \ctikzset{component text=left}
                    \draw;
                    % (0,0) node[demux] (myPort) {HalfAdder};
                    % (myPort.in 1) node [anchor = east] {a}
                    % (myPort.in 2) node [anchor = east] {b}
                    % (myPort.out)  node [anchor = west] {out};
                \end{circuitikz} 
                \caption{Porta Lógica RAM4K}
            \end{figure} \noindent

        \paragraph{Implementação}Esta porta lógica pode ser implementada de acordo com o seguinte código:
            \begin{scriptsize}
                \myStyleVHDL
                \lstinputlisting{./nand2tetris/projects/03/b/RAM4K.hdl}
            \end{scriptsize}
\newpage

    \subsection{RAM16K}
        \paragraph{Definição}[Funcionamento]

        \paragraph{Tabela Verdade}Esta porta lógica possuirá a seguinte tabela verdade:
            \begin{table}[H]
                \centering
                \begin{tabular}[]{cc|c}\hline
                    a & b & out\\\hline
                    0 & 1 & 1\\
                    0 & 1 & 1\\
                    0 & 1 & 1\\
                    0 & 1 & 1\\\hline
                \end{tabular}
                \caption{Tabela Verdade RAM16K}
            \end{table}

        \paragraph{Representação}Esta porta lógica pode ser expressa pelo seguinte circuito:
            \begin{figure}[H]
                \centering
                \begin{circuitikz}
                    \ctikzset{component text=left}
                    \draw;
                    % (0,0) node[demux] (myPort) {HalfAdder};
                    % (myPort.in 1) node [anchor = east] {a}
                    % (myPort.in 2) node [anchor = east] {b}
                    % (myPort.out)  node [anchor = west] {out};
                \end{circuitikz} 
                \caption{Porta Lógica RAM16K}
            \end{figure} \noindent

        \paragraph{Implementação}Esta porta lógica pode ser implementada de acordo com o seguinte código:
            \begin{scriptsize}
                \myStyleVHDL
                \lstinputlisting{./nand2tetris/projects/03/b/RAM16K.hdl}
            \end{scriptsize}
\newpage

    \subsection{PC}
        \paragraph{Definição}[Funcionamento]

        \paragraph{Tabela Verdade}Esta porta lógica possuirá a seguinte tabela verdade:
            \begin{table}[H]
                \centering
                \begin{tabular}[]{cc|c}\hline
                    a & b & out\\\hline
                    0 & 1 & 1\\
                    0 & 1 & 1\\
                    0 & 1 & 1\\
                    0 & 1 & 1\\\hline
                \end{tabular}
                \caption{Tabela Verdade PC}
            \end{table}

        \paragraph{Representação}Esta porta lógica pode ser expressa pelo seguinte circuito:
            \begin{figure}[H]
                \centering
                \begin{circuitikz}
                    \ctikzset{component text=left}
                    \draw;
                    % (0,0) node[demux] (myPort) {HalfAdder};
                    % (myPort.in 1) node [anchor = east] {a}
                    % (myPort.in 2) node [anchor = east] {b}
                    % (myPort.out)  node [anchor = west] {out};
                \end{circuitikz} 
                \caption{Porta Lógica PC}
            \end{figure} \noindent

        \paragraph{Implementação}Esta porta lógica pode ser implementada de acordo com o seguinte código:
            \begin{scriptsize}
                \myStyleVHDL
                \lstinputlisting{./nand2tetris/projects/03/a/PC.hdl}
            \end{scriptsize}
\newpage

    \section{Projeto 4}
        \subsection{Linguagem de Máquina Hack}
            \paragraph{Definição}Linguagem básica utilizada para manipular as portas lógicas implementadas anteriormente, consistindo de comandos binários com palavras de 16-bit. Há duas possíveis instruções suportadas por esta linguagem, descritas a seguir:
                \begin{enumerate}[noitemsep]
                    \item \textbf{A Instructions:} Registrador A assume o valor de \texttt{value}, representado pelo seguinte comando:
                        \begin{scriptsize}
                            \myStyleAssembly
                            \begin{lstlisting}
    @value
                            \end{lstlisting}
                        \end{scriptsize}
                    Este comando também possuirá uma representação em binário de 16-bit, descrito pela seguinte notação:
                        \begin{equation}
                            \boxed{
                            \underbrace{0}_{
                                    \text{instrução \texttt{A}}
                                }
                                \hspace{5mm}
                                \underbrace{000000000000000}_{
                                    \text{\texttt{value} representado em 15-bit}
                                }
                            }
                        \end{equation}
                    \item \textbf{C Instructions:} Realiza a operação \texttt{comp}, armazena o resultado em \texttt{dest} e poderá realizar um deslocamento de acordo com a condição imposta por \texttt{jump};
                        \begin{scriptsize}
                            \myStyleAssembly
                            \begin{lstlisting}
    dest = comp ; jump
                            \end{lstlisting}
                        \end{scriptsize}
                    Este comando também possuirá uma representação em binário de 16-bit, descrito pela seguinte notação:
                        \begin{equation}
                            \boxed{
                            \underbrace{1}_{
                                    \text{instrução \texttt{C}}
                                }
                                \hspace{5mm}
                                \underbrace{11}_{
                                    \text{não utilizado}
                                }
                                \hspace{5mm}
                                \underbrace{\textcolor{darkblue}{\text{a c1 c2 c3 c4 c5 c6}}}_{
                                    \text{\texttt{comp} bits}
                                }
                                \hspace{5mm}
                                \underbrace{\textcolor{darkpurple}{\text{d1 d2 d3}}}_{
                                    \text{\texttt{dest} bits}
                                }
                                \hspace{5mm}
                                \underbrace{\textcolor{darkgreen}{\text{j1 j2 j3}}}_{
                                    \text{\texttt{jump} bits}
                                }
                            }
                        \end{equation}
                    Onde:
                        \begin{enumerate}
                            \item \texttt{comp}: Representa todas as possíveis operações que a \texttt{ALU} poderá realizar, expressas a seguir:
                                \begin{table}[H]
                                    \centering
                                    \begin{tabular}[]{l|cc|cccccc}\hline
                                        Operação     & Resultado  &            & c1& c2& c3& c4& c5&c6\\\hline
                                        Tornar Zero  & 0          &            & 1 & 0 & 1 & 0 & 1 & 0\\
                                        Tornar Um    & 1          &            & 1 & 1 & 1 & 1 & 1 & 1\\
                                        Tornar $-$Um & $-$1       &            & 1 & 1 & 1 & 0 & 1 & 0\\
                                        Manter       & D          &            & 0 & 0 & 1 & 1 & 0 & 0\\
                                                     & A          &  M         & 1 & 1 & 0 & 0 & 0 & 0\\
                                        Negar        & !D         &            & 0 & 0 & 1 & 1 & 0 & 1\\
                                                     & !A         & !M         & 1 & 1 & 0 & 0 & 0 & 1\\
                                        Oposto       & $-$D       &            & 0 & 0 & 1 & 1 & 1 & 1\\
                                                     & $-$A       & $-$M       & 1 & 1 & 0 & 0 & 1 & 1\\
                                        Incrementar  & D+1        &            & 0 & 1 & 1 & 1 & 1 & 1\\
                                                     & A+1        & M+1        & 1 & 1 & 0 & 1 & 1 & 1\\
                                        Decrementar  & D$-$1      &            & 0 & 0 & 1 & 1 & 1 & 0\\
                                                     & A$-$1      & M$-$1      & 1 & 1 & 0 & 0 & 1 & 0\\
                                        Somar        & D+A        & D+M        & 0 & 0 & 0 & 0 & 1 & 0\\
                                        Subtrair     & D$-$A      & D$-$M      & 0 & 1 & 0 & 0 & 1 & 1\\
                                                     & A$-$D      & M$-$D      & 0 & 0 & 0 & 1 & 1 & 1\\
                                        \texttt{AND} & D\&A       & D\&M       & 0 & 0 & 0 & 0 & 0 & 0\\
                                        \texttt{OR}  & D $\mid$ A & D $\mid$ M & 0 & 1 & 0 & 1 & 0 & 1\\\hline
                                                     & a==0       & a==1       &   &   &   &   &   &  \\\hline
                                    \end{tabular}
                                    \caption{Operações \texttt{ALU}}
                                \end{table}\noindent
                            Note que estas entradas corresponderam as entradas da \texttt{ALU}.
                            \item \texttt{dest}: Representa o destino do resultado da operação realizada, expressa a seguir:
                                \begin{table}[H]
                                    \centering
                                    \begin{tabular}[]{l|l|ccc}\hline
                                        Operação      & Armazena                                       & d1& d2& d3\\\hline
                                        \texttt{null} & Descarta Resultado                             & 0 & 0 & 0\\
                                        \texttt{M}    & \texttt{RAM[A]}                                & 0 & 0 & 1\\
                                        \texttt{D}    & Registrador D                                  & 0 & 1 & 0\\
                                        \texttt{MD}   & \texttt{RAM[A]} e Registrador D                & 0 & 1 & 1\\
                                        \texttt{A}    & Registrador A                                  & 1 & 0 & 0\\
                                        \texttt{AM}   & Registrador A e \texttt{RAM[A]}                & 1 & 0 & 1\\
                                        \texttt{AD}   & Registrador A e Registrador D                  & 1 & 1 & 0\\
                                        \texttt{ADM}  & Registrador A, \texttt{RAM[A]} e Registrador D & 1 & 1 & 1\\\hline
                                    \end{tabular}
                                    \caption{Destinos de \texttt{C}}
                                \end{table}\noindent
                            Note que estas entradas corresponderam respectivamente aos loads de cada armazenador; \texttt{A.load = d1}, \texttt{D.load = d2} e \texttt{M.load = d3}.
                            \item \texttt{jump}: Representa qual a condição para o fluxo do programa, expresso a seguir:
                                \begin{table}[H]
                                    \centering
                                    \begin{tabular}[]{l|l|ccc}\hline
                                        Operação      & Resultado          & j1& j2& j3\\\hline
                                        \texttt{null} & no jump            & 0 & 0 & 0\\
                                        \texttt{JGT}  & if out $>0$    jump & 0 & 0 & 1\\
                                        \texttt{JEQ}  & if out $=0$    jump & 0 & 1 & 0\\
                                        \texttt{JGE}  & if out $\ge 0$  jump & 0 & 1 & 1\\
                                        \texttt{JLT}  & if out $<0$    jump & 1 & 0 & 0\\
                                        \texttt{JNE}  & if out $\neq 0$ jump & 1 & 0 & 1\\
                                        \texttt{JLE}  & if out $\le 0$  jump & 1 & 1 & 0\\
                                        \texttt{JMP}  & unconditional jump & 1 & 1 & 1\\\hline
                                    \end{tabular}
                                    \caption{Condições de \texttt{jump}}
                                \end{table}\noindent
                            Note que estas entradas corresponderam respectivamente aos resultados da \texttt{ALU}; \texttt{not(ng) = j1}, \texttt{zr = j2} e \texttt{ng = j3}.
                        \end{enumerate}
                \end{enumerate}
\newpage

        \subsection{Mult}
            \paragraph{Definição}

            \paragraph{Implementação}Este código pode ser implementada de acordo com o seguinte código:
                \begin{scriptsize}
                    \myStyleAssembly
                    \lstinputlisting{./nand2tetris/projects/04/mult/Mult.asm}
                \end{scriptsize}
\newpage

        \subsection{Fill}
            \paragraph{Definição}

            \paragraph{Implementação}Este código pode ser implementada de acordo com o seguinte código:
                \begin{scriptsize}
                    \myStyleAssembly
                    \lstinputlisting{./nand2tetris/projects/04/fill/Fill.asm}
                \end{scriptsize}
\newpage

    \section{Projeto 5}
        \subsection{Arquitetura de Computadores}
            \paragraph{Definição}Estruturação e construção de microcontroladores, definida teoricamente por Alan Turing e estabelecida na prática por John Von Neumann, estabelecendo diferentes blocos básicos:
                \begin{figure}[H]
                    \centering
                    \includegraphics[height = 5cm]{ima0.png}
                    \caption{Hack Processor}\label{fig:hackProcessor}
                \end{figure} \noindent
            Onde:
                \begin{enumerate}[rightmargin = \leftmargin, noitemsep]
                    \item \textbf{Memória:} Responsável por armazenar variáveis do código, separadas em:
                        \begin{enumerate}[rightmargin = \leftmargin, noitemsep]
                            \item \texttt{Data};
                            \item \texttt{Programa};
                        \end{enumerate}
                    \item \textbf{CPU:} Controle das operações realizadas por meio dos seguintes componentes:
                        \begin{enumerate}[rightmargin = \leftmargin, noitemsep]
                            \item \texttt{Registradores};
                            \item \texttt{ALU};
                        \end{enumerate}
                \end{enumerate}
            Estes componentes se comunicam através de 3 vias principais, cada qual responsável por transportar uma parcela das informações do sistema:
                \begin{enumerate}[rightmargin = \leftmargin, noitemsep]
                    \item \textbf{Address Bus:} Transporta os enderenços envolvidos no comando;
                    \item \textbf{Control Bus:} Transporta as instruções a serem executadas;
                    \item \textbf{Data Bus:} Transporta as informações a serem utilizadas;
                \end{enumerate}

            \paragraph{Fetching}Armazenar a localização da próxima instrução na entrada do endereço de memória e obter a instrução através da leitura dessa memória alocada.
\newpage

        \subsection{Memory}
            \paragraph{Definição}[Funcionamento]

            \paragraph{Implementação}Este componente pode ser implementada de acordo com o seguinte código:
                \begin{scriptsize}
                    \myStyleVHDL
                    \lstinputlisting{./nand2tetris/projects/05/Memory.hdl}
                \end{scriptsize}
\newpage

        \subsection{CPU}
            \paragraph{Definição}[Funcionamento]

            \paragraph{Implementação}Este componente pode ser implementada de acordo com o seguinte código:
                \begin{scriptsize}
                    \myStyleVHDL
                    \lstinputlisting{./nand2tetris/projects/05/CPU.hdl}
                \end{scriptsize}
\newpage

        \subsection{Computer}
            \paragraph{Definição}[Funcionamento]

            \paragraph{Implementação}Este componente pode ser implementada de acordo com o seguinte código:
                \begin{scriptsize}
                    \myStyleVHDL
                    \lstinputlisting{./nand2tetris/projects/05/Computer.hdl}
                \end{scriptsize}
\newpage

    \section{Projeto 6}
        \paragraph{Definição}Conjunto gratuito e aberto RISC de Instruction Set Architecture, ou seja, conjunto de regras de desenvolvimento de software e hardware. Recomenda-se a utilização do seguinte \href{https://ascslab.org/research/briscv/simulator/simulator.html#}{Simulador de RISC-V}.

        \subsection{Registradores RISC-V}
            \paragraph{Definição}Processodores elaborados sobre esta Arquitetura possuirão 32 registradores responsáveis por desempenhar funções especificas, cuja descrição seguem abaixo:
                \begin{table}[H]
                    \centering
                    \begin{tabular}[]{l|l}\hline
                        Nome & Descrição\\\hline
                        zero   & Valor Fixo em 0\\
                        t0-t6  & Valores Temporários\\
                        s0-s11 & Valores Salvos\\
                        a0-a7  & Parâmetros e Valores de Retorno de Funções\\
                        ra     & Endereço de Retorno de Função\\
                        sp     & Apontador de Pilha\\\hline
                    \end{tabular}
                    \caption{Registradores RISC-V}
                \end{table}\noindent

        \subsection{Formato de Funções}
            \paragraph{Definição}Há diferentes estruturas de funções que podem ser empregadas, entre as principais estruturas de funções tem-se os seguintes formatos básicos onde \texttt{func} representa uma função genérica, como descrito a seguir:
                \begin{enumerate}[rightmargin = \leftmargin, noitemsep]
                    \item \textbf{3 Arguments Functions:} Registrador \texttt{s0} assume o valor de \texttt{s1 func s2}, representado pelo seguinte comando:
                        \begin{scriptsize}
                            \myStyleAssembly
                            \begin{lstlisting}
    func s0, s1, s2
                            \end{lstlisting}
                        \end{scriptsize}

                    \item \textbf{2 Arguments Functions:} Registrador \texttt{s0} assume o valor de \texttt{s1 func 1}, onde \texttt{1} será nomeado imediato, representado pelo seguinte comando:
                        \begin{scriptsize}
                            \myStyleAssembly
                            \begin{lstlisting}
    func s0, s1, 1
                            \end{lstlisting}
                        \end{scriptsize}

                    \item \textbf{1 Arguments Functions:} Registrador \texttt{s0} assume o valor de \texttt{1}, onde \texttt{1} será nomeado imediato, representado pelo seguinte comando:
                        \begin{scriptsize}
                            \myStyleAssembly
                            \begin{lstlisting}
    func s0, 1
                            \end{lstlisting}
                        \end{scriptsize}
                \end{enumerate}

        \subsection{Instruções Aritméticas}
            \paragraph{Definição}Há diferentes funções aritméticas que permitem realizar matemática aritmética simples na arquitetura \texttt{load/store}, entre as principais instruções tem-se como descrito a seguir:
                \begin{enumerate}[rightmargin = \leftmargin, noitemsep]
                    \item \textbf{ADD Instruction:} Armazenada a soma de \texttt{rs1 + rs2} no registrador \texttt{rd}, representado pelo seguinte comando:
                        \begin{scriptsize}
                            \myStyleAssembly
                            \begin{lstlisting}
    ADD rd, rs1, rs2
                            \end{lstlisting}
                        \end{scriptsize}

                    \item \textbf{ADDI Instruction:} Armazenada a soma de \texttt{rs1 + imm} no registrador \texttt{rd}, representado pelo seguinte comando:
                        \begin{scriptsize}
                            \myStyleAssembly
                            \begin{lstlisting}
    ADDI rd, rs1, imm
                            \end{lstlisting}
                        \end{scriptsize}

                    \item \textbf{SUB Instruction:} Armazenada a subtração de \texttt{rs1 - rs2} no registrador \texttt{rd}, representado pelo seguinte comando:
                        \begin{scriptsize}
                            \myStyleAssembly
                            \begin{lstlisting}
    SUB rd, rs1, rs2
                            \end{lstlisting}
                        \end{scriptsize}
                \end{enumerate}

        \subsection{Instruções Lógicas}
            \paragraph{Definição}Há diferentes funções lógicas que permitem realizar operações simples na arquitetura \texttt{load/store}, entre as principais instruções tem-se como descrito a seguir:
                \begin{enumerate}[rightmargin = \leftmargin, noitemsep]
                    \item \textbf{XOR Instruction:} Armazenada a lógica de \texttt{rs1 XOR rs2} no registrador \texttt{rd}, representado pelo seguinte comando:
                        \begin{scriptsize}
                            \myStyleAssembly
                            \begin{lstlisting}
    XOR rd, rs1, rs2
                            \end{lstlisting}
                        \end{scriptsize}

                    \item \textbf{OR Instruction:} Armazenada a lógica de \texttt{rs1 OR rs2} no registrador \texttt{rd}, representado pelo seguinte comando:
                        \begin{scriptsize}
                            \myStyleAssembly
                            \begin{lstlisting}
    OR rd, rs1, rs2
                            \end{lstlisting}
                        \end{scriptsize}

                    \item \textbf{OR Instruction:} Armazenada a lógica de \texttt{rs1 AND rs2} no registrador \texttt{rd}, representado pelo seguinte comando:
                        \begin{scriptsize}
                            \myStyleAssembly
                            \begin{lstlisting}
    AND rd, rs1, rs2
                            \end{lstlisting}
                        \end{scriptsize}
                \end{enumerate}
            Nota-se que todas as instruções acima descritas possuem variação imediata, ou seja, podem receber alternativamente um valor imediato para realizar a operação.


        \subsection{Instruções de Deslocamento}
            \paragraph{Definição}Há diferentes funções que permitem deslocar lateralmente bits na arquitetura \texttt{load/store}, entre as principais instruções tem-se como descrito a seguir:
                \begin{enumerate}[rightmargin = \leftmargin]
                    \item \textbf{SLL Instruction:} Armazena no registrador \texttt{rd} o deslocamento de \texttt{rs2} bits para esquerda do valor que se encontra em  \texttt{rs1}, representado pelo seguinte comando:
                        \begin{scriptsize}
                            \myStyleAssembly
                            \begin{lstlisting}
    SLL rd, rs1, rs2
                            \end{lstlisting}
                        \end{scriptsize}
                    Este comando multiplica o valor de \texttt{rs1} por $2^{x}$, onde $x$ representa o valor de \texttt{rs2}.

                    \item \textbf{SRL Instruction:} Armazena no registrador \texttt{rd} o deslocamento de \texttt{rs2} bits para direita do valor que se encontra em  \texttt{rs1}, representado pelo seguinte comando:
                        \begin{scriptsize}
                            \myStyleAssembly
                            \begin{lstlisting}
    SRL rd, rs1, rs2
                            \end{lstlisting}
                        \end{scriptsize}
                    Este comando divide o valor de \texttt{rs1} por $2^{x}$, onde $x$ representa o valor de \texttt{rs2}.

                    \item \textbf{SRA Instruction:} Armazena no registrador \texttt{rd} o deslocamento de \texttt{rs2} bits para direita do valor que se encontra em  \texttt{rs1}, representado pelo seguinte comando:
                        \begin{scriptsize}
                            \myStyleAssembly
                            \begin{lstlisting}
    SRA rd, rs1, rs2
                            \end{lstlisting}
                        \end{scriptsize}
                    Este comando, diferentemente do SRL, replica o valor mais significativo do valor, garantindo que o complemento de dois seja conservado.
                \end{enumerate}
            Nota-se que todas as instruções acima descritas possuem variação imediata, ou seja, podem receber alternativamente um valor imediato para realizar a operação, sendo o método normalmente mais utilizado.


        \subsection{Instruções de Memória}
            \paragraph{Definição}Há diferentes funções que permitem acessar e escrever na memória na arquitetura \texttt{load/store}, entre as principais instruções tem-se como descrito a seguir:
                \begin{enumerate}[rightmargin = \leftmargin]
                    \item \textbf{LW Instruction:} Armazena no registrador \texttt{rd} a leitura do endereço dentro de \texttt{rs1 + imm}, representado pelo seguinte comando:
                        \begin{scriptsize}
                            \myStyleAssembly
                            \begin{lstlisting}
    LW rd, rs1, imm
                            \end{lstlisting}
                        \end{scriptsize}

                    \item \textbf{SW Instruction:} Armazena no registrador \texttt{rd} a escrita do endereço de \texttt{rs1}, representado pelo seguinte comando:
                        \begin{scriptsize}
                            \myStyleAssembly
                            \begin{lstlisting}
    SW rd, rs1, imm
                            \end{lstlisting}
                        \end{scriptsize}
                \end{enumerate}
            Neste conjunto de instruções será necessário fornecer a localização do vetor utilizado com relação a seu início. Como \texttt{32 bits = 4 bytes} os imediatos fornecidos as funções serão múltiplos do tamanho de palavra que estiver sendo lida, como representado pela seguinte tabela:
                \begin{table}[H]
                    \centering
                    \begin{tabular}[]{c|cc}\hline
                        Linguagem C & Variáveis em RISC-V & Tamanho em Bytes\\\hline
                        bool        & byte             & 1\\
                        char        & byte             & 1\\
                        short       & halfword         & 2\\
                        int         & word             & 4\\
                        long        & word             & 4\\
                        void        & unsigned word    & 4\\\hline
                    \end{tabular}
                    \caption{Variavéis RISC-V}
                \end{table}\noindent

        \subsection{Instruções de Comparação}
            \paragraph{Definição}Há diferentes funções que permitem, limitadamente, comparar valores na arquitetura \texttt{load/store}, entre as principais instruções tem-se como descrito a seguir:
                \begin{enumerate}[rightmargin = \leftmargin]
                    \item \textbf{SLT Instruction:} Armazena no registrador \texttt{rd} a comparação se o valor em \texttt{rs1} é menor do que o valor em \texttt{rs2}, representado pelo seguinte comando:
                        \begin{scriptsize}
                            \myStyleAssembly
                            \begin{lstlisting}
    SLT rd, rs1, rs2
                            \end{lstlisting}
                        \end{scriptsize}
                    Este, comando apresentaram as variações imediatas, não sinalizadas e a combinação entre imediata e não sinalizada.
                \end{enumerate}


        \subsection{Instruções de Salto Condicional}
            \paragraph{Definição}Há diferentes funções que permitem, com base em uma comparação, ir para outra posição de memória na arquitetura \texttt{load/store}, entre as principais instruções tem-se como descrito a seguir:
                \begin{enumerate}[rightmargin = \leftmargin]
                    \item \textbf{BEQ Instruction:} Desloca-se para a posição de \texttt{imm} se o valor de \texttt{rs1 == rs2}, representado pelo seguinte comando:
                        \begin{scriptsize}
                            \myStyleAssembly
                            \begin{lstlisting}
    BEQ rs1, rs2, imm
                            \end{lstlisting}
                        \end{scriptsize}

                    \item \textbf{BNE Instruction:} Desloca-se para a posição de \texttt{imm} se o valor de \texttt{rs1 != rs2}, representado pelo seguinte comando:
                        \begin{scriptsize}
                            \myStyleAssembly
                            \begin{lstlisting}
    BNE rs1, rs2, imm
                            \end{lstlisting}
                        \end{scriptsize}

                    \item \textbf{BLT Instruction:} Desloca-se para a posição de \texttt{imm} se o valor de \texttt{rs1 < rs2}, representado pelo seguinte comando:
                        \begin{scriptsize}
                            \myStyleAssembly
                            \begin{lstlisting}
    BLT rs1, rs2, imm
                            \end{lstlisting}
                        \end{scriptsize}
                    Este, comando apresentará a variação não sinalizada.

                    \item \textbf{BGE Instruction:} Desloca-se para a posição de \texttt{imm} se o valor de \texttt{rs1 >=rs2}, representado pelo seguinte comando:
                        \begin{scriptsize}
                            \myStyleAssembly
                            \begin{lstlisting}
    BGE rs1, rs2, imm
                            \end{lstlisting}
                        \end{scriptsize}
                    Este, comando apresentará a variação não sinalizada.
                \end{enumerate}

        \subsection{Códigos Básicos}
            \paragraph{Definição}Há diferentes estruturas comumente empregadas em código, entre os principais métodos tem-se como descrito a seguir:
                \begin{enumerate}[rightmargin = \leftmargin]
                    \item \textbf{if Estrutura:} Realização de uma comparação e separação do código, representado pelos seguintes comandos:\\
                        \begin{minipage}[t]{0.45\linewidth}
                            \begin{scriptsize}
                                \myStyleC
                                \begin{lstlisting}
#include<stdio.h>
int main()
{
    int t0 = 9;
    int t1 = 0;
    int t2 = 5;

    if (t0 == t2)
    {
        t1 += 7;
    } else {
        t1 += 15;
    }
}

                                \end{lstlisting}
                            \end{scriptsize}
                        \end{minipage}
                            \hspace{12.5mm}
                        \begin{minipage}[t]{0.45\linewidth}
                            \begin{scriptsize}
                                \myStyleAssembly
                                \begin{lstlisting}
main:
    addi t0, zero, 9
    addi t1, zero, 0
    addi t2, zero, 5

    bne t0, t2, else
    addi t1, t1, 7
    j fim

else:
    addi t1, t1, 15

fim:
    jr ra
                                \end{lstlisting}
                            \end{scriptsize}
                        \end{minipage}
                \item \textbf{while Estrutura:} Realização de \texttt{loop} do código, representado pelos seguintes comandos:\\
                    \begin{minipage}[t]{0.45\linewidth}
                        \begin{scriptsize}
                            \myStyleC
                            \begin{lstlisting}
#include<stdio.h>
int main()
{
    int t0 = 20;
    int t1 = 10;

    while (t0 != t1)
    {
        t0 += 2;
        t1 += 3;
    }
}
                            \end{lstlisting}
                        \end{scriptsize}
                    \end{minipage}
                        \hspace{12.5mm}
                    \begin{minipage}[t]{0.45\linewidth}
                        \begin{scriptsize}
                            \myStyleAssembly
                            \begin{lstlisting}
main:
    addi t0, zero, 20
    addi t1, zero, 10

while:
    beq t0, t1, fim
    addi t0, t0, 2
    addi t1, t1, 3
    j while

fim:
    jr ra
                                \end{lstlisting}
                            \end{scriptsize}
                    \end{minipage}

                \item \textbf{for Estrutura:} Realização de \texttt{loop} do código, representado pelos seguintes comandos:\\
                    \begin{minipage}[t]{0.45\linewidth}
                        \begin{scriptsize}
                            \myStyleC
                            \begin{lstlisting}
#include<stdio.h>
int main()
{
    int t0 = 0;
    int t1 = 0;
    int t2 = 100;

    for (t0 = 0; t0 < t1; t0++)
    {
        t2 += t0;
    }

}
                            \end{lstlisting}
                        \end{scriptsize}
                    \end{minipage}
                        \hspace{12.5mm}
                    \begin{minipage}[t]{0.45\linewidth}
                        \begin{scriptsize}
                            \myStyleAssembly
                            \begin{lstlisting}
main:
    addi t0, zero, 0
    addi t1, zero, 0
    addi t2, zero, 100

for:
    bge t1, t2, fim
    addi t0, t0, t1
    addi t1, t1, 1
    j for

fim:
    jr ra
                            \end{lstlisting}
                        \end{scriptsize}
                    \end{minipage}
            \end{enumerate}
\newpage

        \subsection{Programas}
            \begin{enumerate}[rightmargin = \leftmargin]
                \item \textbf{Triângulo}:
                    \begin{scriptsize}
                        \myStyleAssembly
                        \lstinputlisting{examples/lab06/mc404_tri.s}
                    \end{scriptsize}
\newpage
                \item \textbf{Multiplicação}:
                    \begin{scriptsize}
                        \myStyleAssembly
                        \lstinputlisting{examples/lab06/mc404_mul.s}
                    \end{scriptsize}
            \end{enumerate}
\newpage

    \section{Projeto 7}
        \paragraph{Definição}Assim como outras linguagens o RISC-V seguem uma sequência de convenções, regras estabelecida entre os usuários, para utilização e aplicação desta linguagem. Recomenda-se que sejam seguidas para garantir a compreensão de seu código.

        \subsection{Endereçamento da Memória}
            \paragraph{Definição}Sequência utilizada para armazenar uma palavra de \texttt{4 bytes}, ou seja \texttt{32 bits}, na memória, diferenciando a ordem de leitura e escrita através dos seguintes métodos:
                \begin{enumerate}[rightmargin = \leftmargin, noitemsep]
                    \item \textbf{Big Endian}: Aloca o \texttt{byte} mais significativo, \texttt{MSB}, primeiro;
                    \item \textbf{Little Endian}: Aloca o \texttt{byte} menos significativo, \texttt{LSB}, primeiro;
                \end{enumerate}
            Esta configuração demonstra apenas como o processor lerá cada palavra de sua memória, iniciando pelo $MSB$ ou pelo $LSB$. Desta maneira pode-se considerar o seguinte exemplo:
                \begin{equation}
                    \boxed{
                        \underbrace{\text{H}}_{
                            \text{0x48}
                        }
                        \hspace{5mm}
                        \underbrace{\text{E}}_{
                            \text{0x45}
                        }
                        \hspace{5mm}
                        \underbrace{\text{L}}_{
                            \text{0x4C}
                        }
                        \hspace{5mm}
                        \underbrace{\text{L}}_{
                            \text{0x4C}
                        }
                        \hspace{5mm}
                        \underbrace{\text{O}}_{
                            \text{0x4F}
                        }
                        \hspace{5mm}
                        \underbrace{\text{!}}_{
                            \text{0x21}
                        }
                        \hspace{5mm}
                        \underbrace{\text{}}_{
                            \text{0x00}
                        }
                    }
                \end{equation}\\
                \begin{center}
                    \begin{minipage}[t]{0.425\linewidth}
                        \textbf{Código Little Endian:}
                        \begin{scriptsize}
                            \myStyleAssembly
                            \begin{lstlisting}
    .word 0x4C4C4548
    .word 0x0000214F
                            \end{lstlisting}
                        \end{scriptsize}
                        \vspace{12.5mm}
                        \textbf{Código Big Endian:}
                        \begin{scriptsize}
                            \myStyleAssembly
                            \begin{lstlisting}
    .word 0x48454C4C
    .word 0x4F210000
                            \end{lstlisting}
                        \end{scriptsize}
                    \end{minipage}
                        \hspace{12.5mm}
                    \begin{minipage}[t]{0.425\linewidth}
                        \textbf{Memória:}
                        \begin{table}[H]
                            \centering
                            \begin{tabular}[]{c|c|c|}
                                Adress & Little Endian & Big Endian\\
                                0 & H & \\
                                1 & E & \\
                                2 & L & !\\
                                3 & L & O\\
                                4 & O & L\\
                                5 & ! & L\\
                                6 &   & E\\
                                7 &   & H\\
                            \end{tabular}
                            \caption{Estrutura de Memoria em RISC-V}
                        \end{table}\noindent
                    \end{minipage}
                \end{center}\noindent
            Note que está diferença não influência para a leitura do código, pois isto influenciará apenas o processamento do processador. RISC-V é padronizado em \texttt{Little Endian}, desta forma será necessário atentar-se quando outros dispositivos sejam \texttt{Big Endian}.

        \subsection{Execução de Funções}
            \paragraph{Definição}Trechos de código que executam uma tarefa específica organizadas separadamente para facilitar seu reuso e legibilidade dentro das convenções utilizadas, abaixo serão listados as principais:
                \begin{enumerate}[noitemsep]
                    \item \textbf{Atribuição de Variável}: Parâmetros utilizados na função serão sequênciados a partir de \texttt{a0}, \texttt{a1}, ...;

                    \item \textbf{Retorno de Variável}: Valores retornados na função serão sequênciados a partir de \texttt{a0}, \texttt{a1}, ...; 
                \end{enumerate}
            Note que quando uma função for executada variáveis atualmente armazenadas em registradores podem ser perdidas, pois durante a execução da função estes locais de memória podem ser acessados e reescritos. Desta maneira recomenda-se salvar as variáveis necessárias na pilha, deslocando o espaço de memória quando não for mais necessário.

        \subsection{Pilha}
            \paragraph{Definição}Espaço da memória reservado para armazenar elementos momentaneamente cujo controle partirá do usuário. Nesta arquitetura o registrador \texttt{sp} sempre apontará para o último elemento da Pilha.

            \paragraph{Organização de Memória}Processadores terão suas memórias organizadas com objetivo de otimizar sua utilização, desta maneira será divida nos seguintes espaços:
                \begin{enumerate}[rightmargin = \leftmargin, noitemsep]
                    \item \textbf{Pilha}: Inicia-se no fim da memória e cresce para baixo;
                    \item \textbf{Heap}: Inicia-se no começo da memória e cresce para cima;
                \end{enumerate}
                \begin{table}[H]
                    \centering
                    \begin{tabular}[]{|c|}\hline
                        $\downarrow$ Pilha\\
                        \\
                        $\vdots$\\
                        \\
                        $\uparrow$ Heap\\
                        Dados\\
                        Programa\\\hline
                    \end{tabular}
                    \caption{Estrutura de Memoria em RISC-V}
                \end{table}\noindent
            Note que desta forma há diferentes combinações possíveis entre as memórias, sendo apenas limitadas pela outra. Assim, o \textbf{Heap} poderá crescer até encontrar-se com a \textbf{Pilha} e vice-versa, possibilitando flexibilixar e maximizar a utilização da memória disponível. Caso deseja-se alocar espaço na \textbf{Pilha} recomenda-se utilizar a seguinte abordagem:
                \begin{center}
                    \begin{minipage}[t]{0.425\linewidth}
                        \textbf{Início:}
                        \begin{scriptsize}
                            \myStyleAssembly
                            \begin{lstlisting}
    addi sp, sp, -8
    sw   ra, 0(sp)
    sw   s0, 4(sp)
                            \end{lstlisting}
                        \end{scriptsize}
                    \end{minipage}
                        \hspace{12.5mm}
                    \begin{minipage}[t]{0.425\linewidth}
                        \textbf{Final:}
                        \begin{scriptsize}
                            \myStyleAssembly
                            \begin{lstlisting}
    lw   s0, 4(sp)
    lw   ra, 0(sp)
    addi sp, sp, 8
                            \end{lstlisting}
                        \end{scriptsize}
                    \end{minipage}
                \end{center}\noindent
\newpage

        \subsection{Programas}
            \begin{enumerate}[rightmargin = \leftmargin]
                \item \textbf{Menor Valor Vetor}:
                    \begin{scriptsize}
                        \myStyleAssembly
                        \lstinputlisting{examples/lab07/mc404_smaVec.s}
                    \end{scriptsize}
\newpage
                \item \textbf{Soma Vetores}:
                    \begin{scriptsize}
                        \myStyleAssembly
                        \lstinputlisting{examples/lab07/mc404_sumVec.s}
                    \end{scriptsize}
            \end{enumerate}
\newpage

    \section{Projeto 8}
        \paragraph{Definção}Linguagens Assembly são diretamente interligadas com o hardware envolvido, trazendo limitações a execução de instruções. Desta maneira, existem maneiras de armazenar e manipular variáveis com \texttt{32 bits} através do espaço reservado a instruções dentro dos registradores.

        \subsection{Constantes de 32 bits}
            \paragraph{Defição}Instruções que manipulam valores imediatos só utilizam os \texttt{12 bits inferiores} dos registradores para armazenar os valores, pelas restrições trazidas pelas implementações de operações. Desta maneira pode-se utilizar as seguintes instruções para manipular os \texttt{20 bits superiores} quando necessário:
                \begin{equation}
                    \boxed{
                    \underbrace{\text{0000 0000 0000 0000 0000}}_{
                            \text{\texttt{20 bits superiores}}
                        }
                        \hspace{5mm}
                        \underbrace{\text{0000 0000 0000}}_{
                            \text{\texttt{12 bits inferiores}}
                        }
                    }
                \end{equation}
            Note que os espaços foram incluidos para facilitar o entendimento dos bits e devem ser desprezados durante a execução das instruções. As seguinte instruções permintem a manipulação dos registradores:
                \begin{enumerate}[rightmargin = \leftmargin]
                    \item \textbf{LUI Instruction:} Adiciona-se o valor da posição de \texttt{imm} de \texttt{20 bits} nos bits superiores da posição \texttt{rs1}, representado pelo seguinte comando:
                        \begin{scriptsize}
                            \myStyleAssembly
                            \begin{lstlisting}
    LUI rs1, imm
                            \end{lstlisting}
                        \end{scriptsize}
                    Note que o comando \texttt{ADDI} adicionará um valor de \texttt{12 bits} nos bits inferiores da posição desejada.
                \end{enumerate}

        \subsection{Manipulação de Bits}
            \paragraph{Definição}Operações lógicas com os bits armazenados em um registrador permitem extrair resultados importantes sobre seus valores. Algumas lógicas comumente aplicadas estão descritas a seguir:
                \begin{enumerate}[rightmargin = \leftmargin]
                    \item \textbf{OR Instruction:} Realizar esta operação terá o seguinte efeito sobre os bits armazenados:
                        \begin{table}[H]
                            \centering
                            \begin{tabular}[]{c|cc}\hline
                                OR   & a[i] & imm\\\hline
                                1    & a[i] & 1\\
                                a[i] & a[i] & 0\\\hline
                            \end{tabular}
                            \caption{Operação OR}
                        \end{table}\noindent

                    \item \textbf{AND Instruction:} Realizar esta operação terá o seguinte efeito sobre os bits armazenados:
                        \begin{table}[H]
                            \centering
                            \begin{tabular}[]{c|cc}\hline
                                AND  & a[i] & imm\\\hline
                                a[i] & a[i] & 1\\
                                0    & a[i] & 0\\\hline
                            \end{tabular}
                            \caption{Operação AND}
                        \end{table}\noindent

                    \item \textbf{XOR Instruction:} Realizar esta operação terá o seguinte efeito sobre os bits armazenados:
                        \begin{table}[H]
                            \centering
                            \begin{tabular}[]{c|cc}\hline
                                XOR                      & a[i] & imm\\\hline
                                $\overline{\text{a[i]}}$ & a[i] & 1\\
                                a[i]                     & a[i] & 0\\\hline
                            \end{tabular}
                            \caption{Operação XOR}
                        \end{table}\noindent
                \end{enumerate}
            Isso possibilita os seguintes resultados:
                \begin{enumerate}[rightmargin = \leftmargin]
                    \item \textbf{Número Par:} Análisa-se o último bit do valor no registrador \texttt{rs1} e armazena 1 se for par na posição \texttt{rd}, representado pelo seguinte comando:
                        \begin{scriptsize}
                            \myStyleAssembly
                            \begin{lstlisting}
    ANDI rd, rs1, 1
                            \end{lstlisting}
                        \end{scriptsize}
                    Note que o comando poderia ser aplicado para diferentes multiplicidades, basta alterar o imediato.

                    \item \textbf{Zerar Bits:} Análisa-se os bits do valor no registrador \texttt{rs1} e zera aqueles nas posições com 0 do \texttt{imm}, armazenando o resultado em \texttt{rd}, representado pelo seguinte comando:
                        \begin{scriptsize}
                            \myStyleAssembly
                            \begin{lstlisting}
    ANDI rd, rs1, 0xFF0
                            \end{lstlisting}
                        \end{scriptsize}
                    Note que o comando poderia ser aplicado para diferentes bits do código com números binários ou hexadecimais, basta alterar o imediato.

                \item \textbf{Ativar Bits:} Análisa-se os bits do valor no registrador \texttt{rs1} e ativa aqueles nas posições com 1 do \texttt{imm}, armazenando o resultado em \texttt{rd}, representado pelo seguinte comando:
                    \begin{scriptsize}
                        \myStyleAssembly
                        \begin{lstlisting}
    ORI rd, rs1, 0xFF0
                        \end{lstlisting}
                    \end{scriptsize}
                Note que o comando poderia ser aplicado para diferentes bits do código com números binários ou hexadecimais, basta alterar o imediato.

                \item \textbf{Inverter Bits:} Análisa-se os bits do valor no registrador \texttt{rs1} e inverte aqueles nas posições com 1 do \texttt{imm}, armazenando o resultado em \texttt{rd}, representado pelo seguinte comando:
                    \begin{scriptsize}
                        \myStyleAssembly
                        \begin{lstlisting}
    XORI rd, rs1, 0xFF0
                        \end{lstlisting}
                    \end{scriptsize}
                Note que o comando poderia ser aplicado para diferentes bits do código com números binários ou hexadecimais, basta alterar o imediato.
        \end{enumerate}

        \subsection{Representação de Caracteres}
            \paragraph{Definição}Convenção necessária para representação de strings dentro das instruções binárias convertendo valores em caracteres distintos. Estas convenções mudaram ao longo do desenvolvimento de software, onde as seguintes convenções são as mais relevantes:
                \begin{enumerate}[rightmargin = \leftmargin]
                    \item \textbf{ASCII:} Representação utilizando \texttt{7 bits}, mais simples e antiga codificação de caracteres, onde o quinto bit indica, no caso das letras, se é maíusculo e minusculo.
                    \item \textbf{ISO8859:} Representação utilizando \texttt{8 bits} de codificação de caracteres, onde o acentuações mais utilizadas foram implementadas.
                    \item \textbf{UTF:} Representação utilizando quantidades variáveis de bits, onde uma referência principal é implementada para facilitar sua expansão.
                \end{enumerate}
            No RISC-V a manipulação de strings se dá pela manipulação de bytes na memória, desta maneira os seguintes comandos podem ser empregrados:
                \begin{enumerate}[rightmargin = \leftmargin]
                    \item \textbf{LBU Instruction:} Carrega o valor de um byte não sinalizado no registrador \texttt{rs1} e o armazena na posição \texttt{rd} pelo deslocamento indicado pelo \texttt{imm}, representado pelo seguinte comando:
                        \begin{scriptsize}
                            \myStyleAssembly
                            \begin{lstlisting}
    LBU rd, rs1, imm
                            \end{lstlisting}
                        \end{scriptsize}

                    \item \textbf{LHU Instruction:} Carrega o valor de um half byte não sinalizado no registrador \texttt{rs1} e o armazena na posição \texttt{rd} pelo deslocamento indicado pelo \texttt{imm}, representado pelo seguinte comando:
                        \begin{scriptsize}
                            \myStyleAssembly
                            \begin{lstlisting}
    LBU rd, rs1, imm
                            \end{lstlisting}
                        \end{scriptsize}

                    \item \textbf{SB Instruction:} Armazena o valor carregado da posição \texttt{rs2} de um byte no registrador \texttt{rs1} pelo deslocamento indicado pelo \texttt{imm}, representado pelo seguinte comando:
                        \begin{scriptsize}
                            \myStyleAssembly
                            \begin{lstlisting}
    SB rs1, rs2, imm
                            \end{lstlisting}
                        \end{scriptsize}

                    \item \textbf{SH Instruction:} Armazena o valor carregado da posição \texttt{rs2} de um half byte no registrador \texttt{rs1} pelo deslocamento indicado pelo \texttt{imm}, representado pelo seguinte comando:
                        \begin{scriptsize}
                            \myStyleAssembly
                            \begin{lstlisting}
    SH rs1, rs2, imm
                            \end{lstlisting}
                        \end{scriptsize}
                \end{enumerate}
            Note que nestes comandos o final das strings será indicado por \texttt{"\ 0"}.
\end{document}