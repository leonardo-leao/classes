\documentclass{article}
\usepackage{tpack}


\title{MC732 - Projeto Sistemas Computacionais}
\author{Guilherme Nunes Trofino}
\authorRA{217276}
\project{Resumo Teórico}


\begin{document}
    \maketitle
\newpage

    \tableofcontents
\newpage
\section{}


\section{RISC-V Processors}
\subsection{Design Principles}
    \begin{enumerate}
        \item \textbf{Simplicity} favours regularity;
        \item \textbf{Smaller} is faster;
        \item Good design demands good \textbf{Compromises};
    \end{enumerate}

\subsection{Registers}
    \begin{table}[H]
        \centering\begin{tabular}{rl | l}\hline
            x0              & zero  & Constant Value 0\\
            x1              & ra    & Return Address\\
            x2              & sp    & Stack Pointer\\
            x3              & gp    & Global Pointer\\
            x4              & tp    & Thread Pointer\\
            x5-x7, x28-x31  & t0-t6 & Temporaries\\
            x8              & fp    & Frame Pointer\\
            x9,    x18-x27  & s0-s11& Saved Registers\\
            x10-x17         & a0-a7 & Function Arguments\\\hline
        \end{tabular}
        \caption{RISC-V Registers}
        \label{tab:riscvRegisers}
    \end{table}
\noindent Note que os temporaries registers podem ser manipulados livremente e não preocupa-se com "sujá-los".\\

\noindent Por outro lado, saved registers devem ser salvos e restaurados caso estes sejam utilizados pela função callee.

\subsection{Functions}
    \begin{enumerate}[rightmargin = \leftmargin]
        \item \textbf{Function Arguments:} Place parameters in registers x10 to x17;
        \item \textbf{Procedure Call:} Transfer control to procedure;
        \begin{scriptsize}
            \myStyleRISCV
            \begin{lstlisting}
    jal x1, ProcedureLabel  # jal ra, ProcedureLabel
            \end{lstlisting}
        \end{scriptsize}
        \item \textbf{Heap Store:} Acquire storage for procedure;
        \begin{scriptsize}
            \myStyleRISCV
            \begin{lstlisting}
    addi sp, sp, -16   # 16 = 4 * n, n: number of words
    sw   x20, 0(sp)
    sw   x19, 4(sp)
    sw   x18, 8(sp)
    sw   ra, 12(sp)
            \end{lstlisting}
        \end{scriptsize}
        \item \textbf{Function Execution:} Perform procedure's operations;
        \item \textbf{Heap Restore:} Place result in register for caller;
        \begin{scriptsize}
            \myStyleRISCV
            \begin{lstlisting}
    lw   ra, 12(sp)
    lw   x18, 8(sp)
    lw   x19, 4(sp)
    lw   x20, 0(sp)
    addi sp, sp, +16   # 16 = 4 * n, n: number of words
            \end{lstlisting}
        \end{scriptsize}
        \item \textbf{Procedure Return:} Return to place of call;
        \begin{scriptsize}
            \myStyleRISCV
            \begin{lstlisting}
    jalr x0, 0(x1)  # jalr zero, 0(ra)
            \end{lstlisting}
        \end{scriptsize}
    \end{enumerate}


\newpage\section{RISC-V Datapath}


\newpage\section{RISC-V Pipelining}
\paragraph{Definição}Performance de processadores RISC-V, quando mono ciclo, será determinado por seu caminho crítico: \texttt{load instruction}. Variar o período de ciclo para diferentes instruções violaria o design principle:
\begin{phrase}
    Making the common case \textbf{Fast}
\end{phrase}
\noindent Dessa forma implementa-se Pipelining para aprimorar o tempo de execução dos processadores RISC-V.\\

\noindent Isso só é possível pois a ISA, Instruction Set Architecture, do RISC-V é desenvolvida para o Pipelining. Todas suas instruções são 32-bits o que permite decodificá-las independentemente de forma direta e previsível.

\subsection{Estágios}
\paragraph{Definição}Considera-se que a cada ciclo cada instrução será analisada nos seguintes estágios:
\begin{figure}[H]
    \centering
    \includegraphics[width = 1\linewidth]{images/datapath_pipelined_1.png}
    \caption{Datapath Pipelined}
    \label{datapath_pipelined}
\end{figure}
\noindent Note que as setas em azul representa informações que vão da direita para esquerda, retornam ao longo do datapath podendo gerar Hazards.\\

\noindent Note também que, nesta implementação inicial, o resultado do \texttt{branch} será resolvido no quarto estágio do datapath.\\

\noindent Implementações mais otimizadas, mostradas posteriormente, obtêm o resultado adequado em estágios anteriores ao utilizar-se de mais hardware.

\subsection{Hazards}
\paragraph{Definição}Situações inesperadas que podem impossibilitar o início do processamento da próxima instrução no próximo ciclo sendo classificadas como:
\begin{enumerate}[rightmargin = \leftmargin]
    \item \textbf{Structure Hazards}: Recurso ocupado com a instrução anterior;
    \begin{enumerate}[rightmargin = \leftmargin]
        \item \texttt{Separate Memory}: Hardware extra é implementado para evitar conflito para acessar memória;
    \end{enumerate}

    \item \textbf{Data Hazards}: Dado dependente da instrução anterior;
    \begin{enumerate}[rightmargin = \leftmargin]
        \item \texttt{Forwarding}: Ocorre entre duas R Instructions:
        \begin{scriptsize}
            \myStyleRISCV
            \begin{lstlisting}
    add  x2, x1, x0 # R Instruction  add1
    add  x4, x3, x2 # R Instruction  add2
            \end{lstlisting}
        \end{scriptsize}
        Inicialmente considera-se que a próxima instrução, \texttt{add2}, só teria acesso ao dado em \texttt{x2} quando \texttt{add1} finalizasse o último estágio do pipeline e houvesse escrita no banco de registradores.\\

        \noindent Isso causaria 2 bubbles até que a instrução \texttt{add2} possa operar como representado abaixo:
        \begin{figure}[H]
            \centering
            \includegraphics[width = 0.8\textwidth]{images/hazard_data.png}
            \caption{Data Hazard}
            \label{hazardData}
        \end{figure}
        
        Entretanto o dado de \texttt{x2} já está calculado ao finalizar a etapa de execução. Dessa forma uma conexão entre a saída da ALU e a entrada da ALU eliminaria o atraso como representado abaixo:
        \begin{figure}[H]
            \centering
            \includegraphics[width = 0.8\textwidth]{images/hazard_data_forwarding.png}
            \caption{Data Hazard Forwarding}
            \label{hazardDataForwarding}
        \end{figure}
        Nota-se que para que isso seja realizado será necessário hardware para interpretar adequadamente os \texttt{Forwardings}. Posteriormente será mostrada sua implementação.

        \item \texttt{Load-Use}: Ocorre entre uma Load Instruction e uma R-Instruction:
        \begin{scriptsize}
            \myStyleRISCV
            \begin{lstlisting}
    ld   x1,  0(x0) # Load Instruction
    add  x3, x2, x1 # R    Instruction
            \end{lstlisting}
        \end{scriptsize}
        Apesar de \texttt{Forwarding} evitar atrasos neste caso o atraso é apenas reduzido, pois a próxima instrução, \texttt{add}, só terá acesso ao dado em \texttt{x1} quando \texttt{ld} finalizar o penúltimo estágio do pipeline e houver escrita na memória como representado abaixo:
        \begin{figure}[H]
            \centering
            \includegraphics[width = 0.75\textwidth]{images/hazard_data_load_use.png}
            \caption{Data Hazard Load-Use}
            \label{hazardDataLoadUse}
        \end{figure}
    \end{enumerate}

    \item \textbf{Control Hazards}: Execução dependente da instrução anterior;
    \begin{enumerate}[rightmargin = \leftmargin]
        \item \texttt{Stall}: Interrompimento da Execução;

        \item \texttt{Prediction}: Suposição do resultado:
        \begin{enumerate}
            \item \texttt{Static}:
            \begin{enumerate}[noitemsep, rightmargin = \leftmargin]
                \item Taken:
                \item Not Taken: Branch não executado;
            \end{enumerate}
            \item \texttt{Dynamic}:
            \begin{enumerate}[noitemsep, rightmargin = \leftmargin]
                \item 
            \end{enumerate}
        \end{enumerate}
    \end{enumerate}
\end{enumerate}
\end{document}